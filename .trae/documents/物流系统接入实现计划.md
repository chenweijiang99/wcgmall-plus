# 基于顺丰开放平台API的物流系统接入实现计划

## 一、顺丰开放平台API概述

### 1. 开发环境准备
- **注册地址**：顺丰企业账户中心
- **开放平台地址**：https://open.sf-express.com
- **开发流程**：注册开发者账号 → 登录开放平台 → 创建应用 → 关联API → 沙箱测试 → 生产环境上线

### 2. 支持的核心API
- **运单创建API**：用于创建顺丰运单
- **物流轨迹查询API**：用于查询运单物流信息
- **订单取消API**：用于取消未揽收的运单
- **电子面单打印API**：用于生成电子面单

## 二、系统设计方案

### 1. 数据模型设计

#### 扩展ProductOrder实体
```java
@Data
@TableName("product_order")
public class ProductOrder implements Serializable {
    // 原有字段...
    
    @Schema(description = "顺丰运单号")
    private String sfWaybillNo;
    
    @Schema(description = "物流状态")
    private String logisticsStatus;
    
    @Schema(description = "物流轨迹JSON")
    private String logisticsTrace;
    
    @Schema(description = "运单状态")
    private Integer waybillStatus;
    
    // 原有字段...
}
```

#### 新建SFWaybill实体（可选，用于更详细的顺丰运单信息存储）
```java
@Data
@TableName("sf_waybill")
public class SFWaybill implements Serializable {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    @Schema(description = "订单ID")
    private Long orderId;
    
    @Schema(description = "顺丰运单号")
    private String waybillNo;
    
    @Schema(description = "运单状态")
    private Integer status;
    
    @Schema(description = "寄件人信息")
    private String senderInfo;
    
    @Schema(description = "收件人信息")
    private String receiverInfo;
    
    @Schema(description = "商品信息")
    private String commodityInfo;
    
    @Schema(description = "创建时间")
    private LocalDateTime createTime;
    
    @Schema(description = "更新时间")
    private LocalDateTime updateTime;
}
```

### 2. 顺丰API客户端实现

#### 创建顺丰配置类
```java
@ConfigurationProperties(prefix = "logistics.sf")
@Data
@Component
public class SFConfigProperties {
    private String clientCode;
    private String checkWord;
    private String sandboxUrl;
    private String正式Url;
    private Boolean sandboxEnabled;
    private String appId;
    private String appKey;
}
```

#### 实现顺丰API客户端
```java
@Service
@RequiredArgsConstructor
public class SFClient {
    private final SFConfigProperties config;
    private final RestTemplate restTemplate;
    
    /**
     * 创建顺丰运单
     */
    public SFResponse createWaybill(SFWaybillRequest request) {
        // 1. 构建请求参数
        Map<String, Object> params = buildRequestParams(request);
        
        // 2. 签名处理
        String sign = generateSign(params);
        params.put("msgDigest", sign);
        
        // 3. 发送请求
        String url = config.getSandboxEnabled() ? config.getSandboxUrl() : config.get正式Url();
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<String> entity = new HttpEntity<>(JSON.toJSONString(params), headers);
        
        // 4. 处理响应
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        return JSON.parseObject(response.getBody(), SFResponse.class);
    }
    
    /**
     * 查询物流轨迹
     */
    public SFTraceResponse getLogisticsTrace(String waybillNo) {
        // 实现物流轨迹查询逻辑
    }
    
    /**
     * 生成签名
     */
    private String generateSign(Map<String, Object> params) {
        // 实现顺丰签名算法
    }
    
    /**
     * 构建请求参数
     */
    private Map<String, Object> buildRequestParams(Object request) {
        // 构建顺丰API请求参数
    }
}
```

### 3. 服务层扩展

#### 扩展ProductOrderService
```java
@Service
@RequiredArgsConstructor
public class ProductOrderServiceImpl extends ServiceImpl<ProductOrderMapper, ProductOrder> implements ProductOrderService {
    private final SFClient sfClient;
    private final SFWaybillMapper sfWaybillMapper;
    
    // 原有方法...
    
    @Override
    public boolean deliverOrderWithSF(Long orderId) {
        // 1. 验证订单状态
        ProductOrder order = getById(orderId);
        if (order == null || order.getStatus() != 2) {
            throw new ServiceException("订单状态错误，无法发货");
        }
        
        // 2. 构建顺丰运单请求
        SFWaybillRequest sfRequest = buildSFWaybillRequest(order);
        
        // 3. 调用顺丰API创建运单
        SFResponse sfResponse = sfClient.createWaybill(sfRequest);
        
        // 4. 处理顺丰API响应
        if (!sfResponse.isSuccess()) {
            throw new ServiceException("创建顺丰运单失败：" + sfResponse.getErrorMsg());
        }
        
        // 5. 保存运单信息
        String waybillNo = sfResponse.getWaybillNo();
        saveSFWaybill(order, waybillNo);
        
        // 6. 更新订单状态
        order.setStatus(3); // 已发货
        order.setSfWaybillNo(waybillNo);
        order.setLogisticsStatus("已发货");
        order.setWaybillStatus(1); // 运单已创建
        
        return updateById(order);
    }
    
    @Override
    public String getLogisticsInfo(Long orderId) {
        // 1. 获取订单信息
        ProductOrder order = getById(orderId);
        if (order == null) {
            throw new ServiceException("订单不存在");
        }
        
        // 2. 调用顺丰API查询物流轨迹
        SFTraceResponse traceResponse = sfClient.getLogisticsTrace(order.getSfWaybillNo());
        
        // 3. 更新订单物流信息
        String traceJson = JSON.toJSONString(traceResponse);
        order.setLogisticsTrace(traceJson);
        order.setLogisticsStatus(getLatestStatus(traceResponse));
        updateById(order);
        
        // 4. 返回物流信息
        return traceJson;
    }
    
    /**
     * 构建顺丰运单请求
     */
    private SFWaybillRequest buildSFWaybillRequest(ProductOrder order) {
        // 实现运单请求构建逻辑
    }
    
    /**
     * 保存顺丰运单信息
     */
    private void saveSFWaybill(ProductOrder order, String waybillNo) {
        // 实现运单信息保存逻辑
    }
    
    /**
     * 获取最新物流状态
     */
    private String getLatestStatus(SFTraceResponse traceResponse) {
        // 实现物流状态解析逻辑
    }
}
```

### 4. 控制层实现

#### 管理端API
```java
@RestController
@RequestMapping("/admin/order")
@RequiredArgsConstructor
public class OrderController {
    private final ProductOrderService productOrderService;
    
    // 原有接口...
    
    /**
     * 顺丰发货
     */
    @PostMapping("/deliver/sf/{orderId}")
    public Result<Boolean> deliverWithSF(@PathVariable Long orderId) {
        boolean result = productOrderService.deliverOrderWithSF(orderId);
        return Result.success(result);
    }
    
    /**
     * 查询物流信息
     */
    @GetMapping("/logistics/{orderId}")
    public Result<String> getLogisticsInfo(@PathVariable Long orderId) {
        String logisticsInfo = productOrderService.getLogisticsInfo(orderId);
        return Result.success(logisticsInfo);
    }
    
    // 原有接口...
}
```

#### 用户端API
```java
@RestController
@RequestMapping("/api/order")
@RequiredArgsConstructor
public class ProductOrderController {
    private final ProductOrderService productOrderService;
    
    // 原有接口...
    
    /**
     * 用户查询物流信息
     */
    @GetMapping("/logistics/{orderId}")
    public Result<String> getUserLogisticsInfo(@PathVariable Long orderId) {
        // 验证订单归属
        // ...
        String logisticsInfo = productOrderService.getLogisticsInfo(orderId);
        return Result.success(logisticsInfo);
    }
    
    // 原有接口...
}
```

### 5. 前端实现

#### 管理端订单列表
- 添加"顺丰发货"按钮（仅对"待发货"状态订单显示）
- 添加运单号显示列
- 添加物流状态显示列

#### 物流信息详情页
```vue
<template>
  <div class="logistics-detail">
    <h3>物流信息</h3>
    <el-card>
      <div class="waybill-info">
        <p>运单号：{{ waybillNo }}</p>
        <p>当前状态：{{ logisticsStatus }}</p>
      </div>
      <div class="trace-list">
        <el-timeline>
          <el-timeline-item
            v-for="(item, index) in logisticsTrace"
            :key="index"
            :timestamp="item.acceptTime"
          >
            {{ item.acceptStation }}
          </el-timeline-item>
        </el-timeline>
      </div>
    </el-card>
  </div>
</template>
```

#### 用户端订单详情
- 添加物流信息显示区域
- 支持查看完整物流轨迹
- 显示当前物流状态

## 三、实现步骤

1. **数据库表修改**
   - 扩展product_order表，添加顺丰物流相关字段
   - 可选：创建sf_waybill表用于存储详细运单信息

2. **配置管理**
   - 在application.yml中添加顺丰API相关配置
   - 支持沙箱环境和生产环境的切换

3. **顺丰API客户端实现**
   - 实现顺丰API请求签名算法
   - 封装运单创建、物流查询等核心API
   - 添加异常处理和日志记录

4. **服务层扩展**
   - 实现顺丰发货逻辑
   - 实现物流信息查询和更新逻辑
   - 添加运单信息保存和管理

5. **控制层实现**
   - 添加管理端顺丰发货接口
   - 添加物流信息查询接口
   - 添加用户端物流查询接口

6. **前端实现**
   - 修改管理端订单列表，添加顺丰发货按钮
   - 实现物流信息详情页
   - 修改用户端订单详情，添加物流信息显示

7. **测试验证**
   - 在顺丰沙箱环境中测试运单创建
   - 测试物流轨迹查询
   - 测试不同订单状态下的物流处理
   - 测试异常情况处理

## 四、技术要点

1. **签名算法实现**：严格按照顺丰API文档实现签名算法，确保请求安全
2. **异常处理**：实现完善的异常处理机制，处理API调用失败、参数错误等情况
3. **日志记录**：添加详细的日志记录，便于调试和监控
4. **事务管理**：在发货流程中使用事务，确保数据一致性
5. **性能优化**：合理缓存物流信息，减少API调用次数
6. **安全性**：保护顺丰API密钥，避免泄露

## 五、预期效果

1. 管理员可以在后台直接使用顺丰API发货
2. 自动生成顺丰运单号并更新订单状态
3. 实时查询并展示物流轨迹
4. 用户可以在前端查看完整的物流信息
5. 系统稳定可靠，支持多种异常情况处理
6. 支持从沙箱环境平滑切换到生产环境

## 六、沙箱环境测试计划

1. **准备测试数据**：创建测试订单，确保订单状态为"待发货"
2. **测试运单创建**：调用顺丰沙箱API创建运单，验证运单号生成
3. **测试物流查询**：调用物流轨迹查询API，验证物流信息返回
4. **测试订单状态更新**：验证订单状态从"待发货"更新为"已发货"
5. **测试异常情况**：测试无效订单、重复发货等异常情况的处理

该计划基于顺丰开放平台API实现，具有接入规范、支持顺丰完整物流服务、提供沙箱测试环境等优点，适合作为项目的物流系统接入方案。